# -*- coding: utf-8 -*-
"""7.2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a7Scvwjoc83y_tudkUg-3x90vzeHNN76
"""

def check_input(element):
    """
    Проверяет, является ли элемент строкой.

    Параметр:
    element - любой элемент списка

    Возвращает:
    bool - True если элемент строка, иначе False
    """
    return isinstance(element, str)


def get_substring(s):
    """
    Находит самую длинную подстроку без повторяющихся символов.

    Параметр:
    s (str) - входная строка

    Возвращает:
    str - самая длинная подстрока без повторений
    """
    if not s:
        return ""

    # Словарь для хранения последнего индекса каждого символа
    char_index = {}
    # Начало текущей подстроки
    start = 0
    # Максимальная длина и результат
    max_length = 0
    result = ""

    for i, char in enumerate(s):
        # Если символ уже встречался и его индекс >= начала текущей подстроки
        if char in char_index and char_index[char] >= start:
            # Сдвигаем начало подстроки
            start = char_index[char] + 1

        # Обновляем индекс символа
        char_index[char] = i

        # Проверяем длину текущей подстроки
        current_length = i - start + 1
        if current_length > max_length:
            max_length = current_length
            result = s[start:i+1]

    return result


def main(lst):
    """
    Основная функция, которая находит самую длинную строку в списке
    и самую длинную подстроку без повторений в ней.

    Параметр:
    lst (list) - входной список

    Выводит:
    tuple - (индекс самой длинной строки, найденная подстрока)
    """
    # Находим все строки в списке с их индексами
    string_indices = []
    for i, element in enumerate(lst):
        if check_input(element):
            string_indices.append((i, element))

    # Если строк нет, возвращаем -1 и пустую строку
    if not string_indices:
        print("(-1, '')")
        return (-1, "")

    # Находим самую длинную строку (первую, если несколько одинаковой длины)
    # Сортируем по длине строк (по убыванию) и сохраняем порядок для одинаковых длин
    longest_index, longest_string = max(string_indices, key=lambda x: len(x[1]))

    # Находим самую длинную подстроку без повторений
    substring = get_substring(longest_string)

    # Выводим результат
    print(f"({longest_index}, '{substring}')")
    return (longest_index, substring)